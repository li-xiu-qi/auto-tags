export const techExamples = [
    {
        "inputTags": [
            "#redis",
            "#caching",
            "#security",
            "#docker",
            "#database",
            "#load-balancing",
            "#networking",
            "#database-backups"
        ],
        "document": `How to Set Up a Secure Redis Cache in Production

This guide walks through setting up Redis as a caching solution in a production environment, with a focus on security best practices. We'll cover:

1. Installing and configuring Redis with encryption
2. Setting up authentication
3. Implementing connection pooling
4. Configuring backup strategies
5. Monitoring cache performance

We'll use Docker for deployment and demonstrate integration with Node.js applications.`,
        "response": {
            "tags": [
                "#redis",
                "#caching",
                "#security",
                "#docker",
            ],
            "newTags": [
                "#production-deployment",
                "#infrastructure-monitoring",
            ],
        }
    },

    {
        "inputTags": [
            "#microservices",
            "#devops",
            "#team-management",
            "#agile",
            "#software-testing",
            "#version-control",
            "#code-quality",
        ],
        "document": `Impact of Microservices on Team Productivity

Our 6-month study across 12 development teams revealed that transitioning from monolithic to microservices architecture led to:

"40% reduction in deployment failures",
"60% faster feature delivery",
"Increased team autonomy",
"Higher maintenance complexity",
"Need for improved service discovery",

However, teams smaller than 8 developers reported challenges with the increased operational overhead.`,
        "response": {
            "tags": [
                "#microservices",
                "#devops",
                "#team-management",
            ],
            "newTags": [
                "#productivity-analysis",
                "#architecture-transition",
            ],
        }
    },


    {
        "inputTags": [
            "#nodejs",
            "#debugging",
            "#performance",
            "#web-development",
            "#cloud",
            "#testing",
        ],
        "document": `Debugging Memory Leaks in Node.js Applications

Common causes of memory leaks in Node.js applications and how to identify them:

1. Event listener accumulation
2. Closure memory retention
3. Global variables misuse
4. Stream handling errors

Using Chrome DevTools and heap snapshots for analysis. Includes practical examples and memory profiling techniques.`,
        "response": {
            "tags": [
                "#nodejs",
                "#debugging",
                "#performance",
            ],
            "newTags": [
                "#memory-management",
                "#profiling-tools",
            ],
        }
    },

    {
        "inputTags": [
            "#learning",
            "#react",
            "#frontend",
            "#javascript",
            "#web-design",
            "#coding",
        ],
        "document": `June 8, 2024

Today's learning focus was on React hooks and context API. Spent 3 hours working through the advanced patterns course. Finally understood why useCallback is crucial for performance optimization.

Key insights:
- Memo vs useMemo differences
- Context performance pitfalls
- Custom hooks best practices

Struggled with understanding the reducer pattern initially, but the official docs examples helped clear things up.

Goals for tomorrow: Build a small demo implementing these patterns in my side project.`,
        "response": {
            "tags": [
                "#learning",
                "#react",
                "#frontend",
            ],
            "newTags": [
                "#study-notes",
                "#personal-growth",
            ],
        }
    },
];
